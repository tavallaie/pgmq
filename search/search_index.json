{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Postgres Message Queue (PGMQ) \u00b6 A lightweight message queue. Like AWS SQS and RSMQ but on Postgres. Documentation : https://tembo.io/pgmq/ Source : https://github.com/tembo-io/pgmq Features \u00b6 Lightweight - No background worker or external dependencies, just Postgres functions packaged in an extension Guaranteed \"exactly once\" delivery of messages to a consumer within a visibility timeout API parity with AWS SQS and RSMQ Messages stay in the queue until explicitly removed Messages can be archived, instead of deleted, for long-term retention and replayability Support \u00b6 Postgres 12-16. Table of Contents \u00b6 Postgres Message Queue (PGMQ) Features Support Table of Contents Installation Updating Client Libraries SQL Examples Creating a queue Send two messages Read messages Pop a message Archive a message Delete a message Drop a queue Configuration Partitioned Queues Visibility Timeout (vt) \u2728 Contributors Installation \u00b6 The fastest way to get started is by running the Tembo Docker image, where PGMQ comes pre-installed in Postgres. docker run -d --name postgres -e POSTGRES_PASSWORD = postgres -p 5432 :5432 quay.io/tembo/pg16-pgmq:latest If you'd like to build from source, you can follow the instructions in CONTRIBUTING.md . Updating \u00b6 To update PGMQ versions, follow the instructions in UPDATING.md . Client Libraries \u00b6 Rust Python Community Go Elixir Elixir + Broadway Java (Spring Boot) Kotlin JVM (JDBC) Javascript (NodeJs) .NET SQL Examples \u00b6 # Connect to Postgres psql postgres://postgres:postgres@0.0.0.0:5432/postgres -- create the extension in the \"pgmq\" schema CREATE EXTENSION pgmq ; Creating a queue \u00b6 Every queue is its own table in the pgmq schema. The table name is the queue name prefixed with q_ . For example, pgmq.q_my_queue is the table for the queue my_queue . -- creates the queue SELECT pgmq . create ( 'my_queue' ); create ------------- (1 row) Send two messages \u00b6 -- messages are sent as JSON SELECT * from pgmq . send ( 'my_queue' , '{\"foo\": \"bar1\"}' ); SELECT * from pgmq . send ( 'my_queue' , '{\"foo\": \"bar2\"}' ); The message id is returned from the send function. send ----------- 1 (1 row) send ----------- 2 (1 row) Read messages \u00b6 Read 2 message from the queue. Make them invisible for 30 seconds. If the messages are not deleted or archived within 30 seconds, they will become visible again and can be read by another consumer. SELECT * FROM pgmq . read ( 'my_queue' , 30 , 2 ); msg_id | read_ct | enqueued_at | vt | message --------+---------+-------------------------------+-------------------------------+----------------- 1 | 1 | 2023-08-16 08:37:54.567283-05 | 2023-08-16 08:38:29.989841-05 | {\"foo\": \"bar1\"} 2 | 1 | 2023-08-16 08:37:54.572933-05 | 2023-08-16 08:38:29.989841-05 | {\"foo\": \"bar2\"} If the queue is empty, or if all messages are currently invisible, no rows will be returned. SELECT pgmq . read ( 'my_queue' , 30 , 1 ); msg_id | read_ct | enqueued_at | vt | message --------+---------+-------------+----+--------- Pop a message \u00b6 -- Read a message and immediately delete it from the queue. Returns `None` if the queue is empty. SELECT pgmq . pop ( 'my_queue' ); msg_id | read_ct | enqueued_at | vt | message --------+---------+-------------------------------+-------------------------------+----------------- 1 | 1 | 2023-08-16 08:37:54.567283-05 | 2023-08-16 08:38:29.989841-05 | {\"foo\": \"bar1\"} Archive a message \u00b6 Archiving a message removes it from the queue and inserts it to the archive table. -- Archive message with msg_id=2. SELECT pgmq . archive ( 'my_queue' , 2 ); archive -------------- t (1 row) -- Archive tables have the prefix `a_`: SELECT * FROM pgmq . a_my_queue ; msg_id | read_ct | enqueued_at | archived_at | vt | message --------+---------+------------------------------+-------------------------------+-------------------------------+----------------- 2 | 1 | 2023-04-25 00:55:40.68417-05 | 2023-04-25 00:56:35.937594-05 | 2023-04-25 00:56:20.532012-05 | {\"foo\": \"bar2\"} Delete a message \u00b6 Send another message, so that we can delete it. SELECT pgmq . send ( 'my_queue' , '{\"foo\": \"bar3\"}' ); send ----------- 3 (1 row) Delete the message with id 3 from the queue named my_queue . SELECT pgmq . delete ( 'my_queue' , 3 ); delete ------------- t (1 row) Drop a queue \u00b6 Delete the queue my_queue . SELECT pgmq . drop_queue ( 'my_queue' ); drop_queue ----------------- t (1 row) Configuration \u00b6 Partitioned Queues \u00b6 You will need to install pg_partman if you want to use pgmq partitioned queues. pgmq queue tables can be created as a partitioned table by using pgmq.create_partitioned() . pg_partman handles all maintenance of queue tables. This includes creating new partitions and dropping old partitions. Partitions behavior is configured at the time queues are created, via pgmq.create_partitioned() . This function has three parameters: queue_name: text : The name of the queue. Queues are Postgres tables prepended with q_ . For example, q_my_queue . The archive is instead prefixed by a_ , for example a_my_queue . partition_interval: text - The interval at which partitions are created. This can be either any valid Postgres Duration supported by pg_partman, or an integer value. When it is a duration, queues are partitioned by the time at which messages are sent to the table ( enqueued_at ). A value of 'daily' would create a new partition each day. When it is an integer value, queues are partitioned by the msg_id . A value of '100' will create a new partition every 100 messages. The value must agree with retention_interval (time based or numeric). The default value is daily . retention_interval: text - The interval for retaining partitions. This can be either any valid Postgres Duration supported by pg_partman, or an integer value. When it is a duration, partitions containing data greater than the duration will be dropped. When it is an integer value, any messages that have a msg_id less than max(msg_id) - retention_interval will be dropped. For example, if the max msg_id is 100 and the retention_interval is 60, any partitions with msg_id values less than 40 will be dropped. The value must agree with partition_interval (time based or numeric). The default is '5 days' . Note: retention_interval does not apply to messages that have been deleted via pgmq.delete() or archived with pgmq.archive() . pgmq.delete() removes messages forever and pgmq.archive() moves messages to the corresponding archive table forever (for example, a_my_queue ). In order for automatic partition maintenance to take place, several settings must be added to the postgresql.conf file, which is typically located in the postgres DATADIR . pg_partman_bgw.interval in postgresql.conf . Below are the default configuration values set in Tembo docker images. Add the following to postgresql.conf . Note, changing shared_preload_libraries requires a restart of Postgres. pg_partman_bgw.interval sets the interval at which pg_partman conducts maintenance. This creates new partitions and dropping of partitions falling out of the retention_interval . By default, pg_partman will keep 4 partitions \"ahead\" of the currently active partition. shared_preload_libraries = 'pg_partman_bgw' # requires restart of Postgres pg_partman_bgw . interval = 60 pg_partman_bgw . role = 'postgres' pg_partman_bgw . dbname = 'postgres' Visibility Timeout (vt) \u00b6 pgmq guarantees exactly once delivery of a message within a visibility timeout. The visibility timeout is the amount of time a message is invisible to other consumers after it has been read by a consumer. If the message is NOT deleted or archived within the visibility timeout, it will become visible again and can be read by another consumer. The visibility timeout is set when a message is read from the queue, via pgmq.read() . It is recommended to set a vt value that is greater than the expected time it takes to process a message. After the application successfully processes the message, it should call pgmq.delete() to completely remove the message from the queue or pgmq.archive() to move it to the archive table for the queue. Who uses pgmq? \u00b6 As the pgmq community grows, we'd love to see who is using it. Please send a PR with your company name and @githubhandle. Currently, officially using pgmq: Tembo [ @ChuckHend ] \u2728 Contributors \u00b6 Thanks goes to these incredible people:","title":"PGMQ"},{"location":"#postgres-message-queue-pgmq","text":"A lightweight message queue. Like AWS SQS and RSMQ but on Postgres. Documentation : https://tembo.io/pgmq/ Source : https://github.com/tembo-io/pgmq","title":"Postgres Message Queue (PGMQ)"},{"location":"#features","text":"Lightweight - No background worker or external dependencies, just Postgres functions packaged in an extension Guaranteed \"exactly once\" delivery of messages to a consumer within a visibility timeout API parity with AWS SQS and RSMQ Messages stay in the queue until explicitly removed Messages can be archived, instead of deleted, for long-term retention and replayability","title":"Features"},{"location":"#support","text":"Postgres 12-16.","title":"Support"},{"location":"#table-of-contents","text":"Postgres Message Queue (PGMQ) Features Support Table of Contents Installation Updating Client Libraries SQL Examples Creating a queue Send two messages Read messages Pop a message Archive a message Delete a message Drop a queue Configuration Partitioned Queues Visibility Timeout (vt) \u2728 Contributors","title":"Table of Contents"},{"location":"#installation","text":"The fastest way to get started is by running the Tembo Docker image, where PGMQ comes pre-installed in Postgres. docker run -d --name postgres -e POSTGRES_PASSWORD = postgres -p 5432 :5432 quay.io/tembo/pg16-pgmq:latest If you'd like to build from source, you can follow the instructions in CONTRIBUTING.md .","title":"Installation"},{"location":"#updating","text":"To update PGMQ versions, follow the instructions in UPDATING.md .","title":"Updating"},{"location":"#client-libraries","text":"Rust Python Community Go Elixir Elixir + Broadway Java (Spring Boot) Kotlin JVM (JDBC) Javascript (NodeJs) .NET","title":"Client Libraries"},{"location":"#sql-examples","text":"# Connect to Postgres psql postgres://postgres:postgres@0.0.0.0:5432/postgres -- create the extension in the \"pgmq\" schema CREATE EXTENSION pgmq ;","title":"SQL Examples"},{"location":"#creating-a-queue","text":"Every queue is its own table in the pgmq schema. The table name is the queue name prefixed with q_ . For example, pgmq.q_my_queue is the table for the queue my_queue . -- creates the queue SELECT pgmq . create ( 'my_queue' ); create ------------- (1 row)","title":"Creating a queue"},{"location":"#send-two-messages","text":"-- messages are sent as JSON SELECT * from pgmq . send ( 'my_queue' , '{\"foo\": \"bar1\"}' ); SELECT * from pgmq . send ( 'my_queue' , '{\"foo\": \"bar2\"}' ); The message id is returned from the send function. send ----------- 1 (1 row) send ----------- 2 (1 row)","title":"Send two messages"},{"location":"#read-messages","text":"Read 2 message from the queue. Make them invisible for 30 seconds. If the messages are not deleted or archived within 30 seconds, they will become visible again and can be read by another consumer. SELECT * FROM pgmq . read ( 'my_queue' , 30 , 2 ); msg_id | read_ct | enqueued_at | vt | message --------+---------+-------------------------------+-------------------------------+----------------- 1 | 1 | 2023-08-16 08:37:54.567283-05 | 2023-08-16 08:38:29.989841-05 | {\"foo\": \"bar1\"} 2 | 1 | 2023-08-16 08:37:54.572933-05 | 2023-08-16 08:38:29.989841-05 | {\"foo\": \"bar2\"} If the queue is empty, or if all messages are currently invisible, no rows will be returned. SELECT pgmq . read ( 'my_queue' , 30 , 1 ); msg_id | read_ct | enqueued_at | vt | message --------+---------+-------------+----+---------","title":"Read messages"},{"location":"#pop-a-message","text":"-- Read a message and immediately delete it from the queue. Returns `None` if the queue is empty. SELECT pgmq . pop ( 'my_queue' ); msg_id | read_ct | enqueued_at | vt | message --------+---------+-------------------------------+-------------------------------+----------------- 1 | 1 | 2023-08-16 08:37:54.567283-05 | 2023-08-16 08:38:29.989841-05 | {\"foo\": \"bar1\"}","title":"Pop a message"},{"location":"#archive-a-message","text":"Archiving a message removes it from the queue and inserts it to the archive table. -- Archive message with msg_id=2. SELECT pgmq . archive ( 'my_queue' , 2 ); archive -------------- t (1 row) -- Archive tables have the prefix `a_`: SELECT * FROM pgmq . a_my_queue ; msg_id | read_ct | enqueued_at | archived_at | vt | message --------+---------+------------------------------+-------------------------------+-------------------------------+----------------- 2 | 1 | 2023-04-25 00:55:40.68417-05 | 2023-04-25 00:56:35.937594-05 | 2023-04-25 00:56:20.532012-05 | {\"foo\": \"bar2\"}","title":"Archive a message"},{"location":"#delete-a-message","text":"Send another message, so that we can delete it. SELECT pgmq . send ( 'my_queue' , '{\"foo\": \"bar3\"}' ); send ----------- 3 (1 row) Delete the message with id 3 from the queue named my_queue . SELECT pgmq . delete ( 'my_queue' , 3 ); delete ------------- t (1 row)","title":"Delete a message"},{"location":"#drop-a-queue","text":"Delete the queue my_queue . SELECT pgmq . drop_queue ( 'my_queue' ); drop_queue ----------------- t (1 row)","title":"Drop a queue"},{"location":"#configuration","text":"","title":"Configuration"},{"location":"#partitioned-queues","text":"You will need to install pg_partman if you want to use pgmq partitioned queues. pgmq queue tables can be created as a partitioned table by using pgmq.create_partitioned() . pg_partman handles all maintenance of queue tables. This includes creating new partitions and dropping old partitions. Partitions behavior is configured at the time queues are created, via pgmq.create_partitioned() . This function has three parameters: queue_name: text : The name of the queue. Queues are Postgres tables prepended with q_ . For example, q_my_queue . The archive is instead prefixed by a_ , for example a_my_queue . partition_interval: text - The interval at which partitions are created. This can be either any valid Postgres Duration supported by pg_partman, or an integer value. When it is a duration, queues are partitioned by the time at which messages are sent to the table ( enqueued_at ). A value of 'daily' would create a new partition each day. When it is an integer value, queues are partitioned by the msg_id . A value of '100' will create a new partition every 100 messages. The value must agree with retention_interval (time based or numeric). The default value is daily . retention_interval: text - The interval for retaining partitions. This can be either any valid Postgres Duration supported by pg_partman, or an integer value. When it is a duration, partitions containing data greater than the duration will be dropped. When it is an integer value, any messages that have a msg_id less than max(msg_id) - retention_interval will be dropped. For example, if the max msg_id is 100 and the retention_interval is 60, any partitions with msg_id values less than 40 will be dropped. The value must agree with partition_interval (time based or numeric). The default is '5 days' . Note: retention_interval does not apply to messages that have been deleted via pgmq.delete() or archived with pgmq.archive() . pgmq.delete() removes messages forever and pgmq.archive() moves messages to the corresponding archive table forever (for example, a_my_queue ). In order for automatic partition maintenance to take place, several settings must be added to the postgresql.conf file, which is typically located in the postgres DATADIR . pg_partman_bgw.interval in postgresql.conf . Below are the default configuration values set in Tembo docker images. Add the following to postgresql.conf . Note, changing shared_preload_libraries requires a restart of Postgres. pg_partman_bgw.interval sets the interval at which pg_partman conducts maintenance. This creates new partitions and dropping of partitions falling out of the retention_interval . By default, pg_partman will keep 4 partitions \"ahead\" of the currently active partition. shared_preload_libraries = 'pg_partman_bgw' # requires restart of Postgres pg_partman_bgw . interval = 60 pg_partman_bgw . role = 'postgres' pg_partman_bgw . dbname = 'postgres'","title":"Partitioned Queues"},{"location":"#visibility-timeout-vt","text":"pgmq guarantees exactly once delivery of a message within a visibility timeout. The visibility timeout is the amount of time a message is invisible to other consumers after it has been read by a consumer. If the message is NOT deleted or archived within the visibility timeout, it will become visible again and can be read by another consumer. The visibility timeout is set when a message is read from the queue, via pgmq.read() . It is recommended to set a vt value that is greater than the expected time it takes to process a message. After the application successfully processes the message, it should call pgmq.delete() to completely remove the message from the queue or pgmq.archive() to move it to the archive table for the queue.","title":"Visibility Timeout (vt)"},{"location":"#who-uses-pgmq","text":"As the pgmq community grows, we'd love to see who is using it. Please send a PR with your company name and @githubhandle. Currently, officially using pgmq: Tembo [ @ChuckHend ]","title":"Who uses pgmq?"},{"location":"#contributors","text":"Thanks goes to these incredible people:","title":"\u2728 Contributors"},{"location":"api/sql/functions/","text":"Functions \u00b6 Sending Messages \u00b6 send \u00b6 Send a single message to a queue. pgmq.send( queue_name text, msg jsonb, delay integer DEFAULT 0 ) RETURNS SETOF bigint Parameters: Parameter Type Description queue_name text The name of the queue msg jsonb The message to send to the queue delay integer Time in seconds before the message becomes visible. Defaults to 0. Example: select * from pgmq . send ( 'my_queue' , '{\"hello\": \"world\"}' ); send ------ 4 send_batch \u00b6 Send 1 or more messages to a queue. pgmq.send_batch( queue_name text, msgs jsonb[], delay integer DEFAULT 0 ) RETURNS SETOF bigint Parameters: Parameter Type Description queue_name text The name of the queue msgs jsonb[] Array of messages to send to the queue delay integer Time in seconds before the messages becomes visible. Defaults to 0. select * from pgmq . send_batch ( 'my_queue' , ARRAY [ '{\"hello\": \"world_0\"}' :: jsonb , '{\"hello\": \"world_1\"}' :: jsonb ] ); send_batch ------------ 1 2 Reading Messages \u00b6 read \u00b6 Read 1 or more messages from a queue. The VT specifies the amount of time in seconds that the message will be invisible to other consumers after reading. pgmq.read( queue_name text, vt integer, qty integer) RETURNS SETOF pgmq.message_record Parameters: Parameter Type Description queue_name text The name of the queue vt integer Time in seconds that the message become invisible after reading qty integer The number of messages to read from the queue. Defaults to 1 Example: select * from pgmq . read ( 'my_queue' , 10 , 2 ); msg_id | read_ct | enqueued_at | vt | message --------+---------+-------------------------------+-------------------------------+---------------------- 1 | 1 | 2023 - 10 - 28 19 : 14 : 47 . 356595 - 05 | 2023 - 10 - 28 19 : 17 : 08 . 608922 - 05 | { \"hello\" : \"world_0\" } 2 | 1 | 2023 - 10 - 28 19 : 14 : 47 . 356595 - 05 | 2023 - 10 - 28 19 : 17 : 08 . 608974 - 05 | { \"hello\" : \"world_1\" } ( 2 rows ) read_with_poll \u00b6 Same as read(). Also provides convenient long-poll functionality. When there are no messages in the queue, the function call will wait for max_poll_seconds in duration before returning. If messages reach the queue during that duration, they will be read and returned immediately. pgmq.read_with_poll( queue_name text, vt integer, qty integer, max_poll_seconds integer DEFAULT 5, poll_interval_ms integer DEFAULT 100 ) RETURNS SETOF pgmq.message_record Parameters: Parameter Type Description queue_name text The name of the queue vt integer Time in seconds that the message become invisible after reading. qty integer The number of messages to read from the queue. Defaults to 1. max_poll_seconds integer Time in seconds to wait for new messages to reach the queue. Defaults to 5. poll_interval_ms integer Milliseconds between the internal poll operations. Defaults to 100. Example: select * from pgmq . read_with_poll ( 'my_queue' , 1 , 1 , 5 , 100 ); msg_id | read_ct | enqueued_at | vt | message --------+---------+-------------------------------+-------------------------------+-------------------- 1 | 1 | 2023 - 10 - 28 19 : 09 : 09 . 177756 - 05 | 2023 - 10 - 28 19 : 27 : 00 . 337929 - 05 | { \"hello\" : \"world\" } pop \u00b6 Reads a single message from a queue and deletes it upon read. Note: utilization of pop() results in at-most-once delivery semantics if the consuming application does not guarantee processing of the message. pgmq.pop(queue_name text) RETURNS SETOF pgmq.message_record Parameters: Parameter Type Description queue_name text The name of the queue Example: pgmq =# select * from pgmq . pop ( 'my_queue' ); msg_id | read_ct | enqueued_at | vt | message --------+---------+-------------------------------+-------------------------------+-------------------- 1 | 2 | 2023 - 10 - 28 19 : 09 : 09 . 177756 - 05 | 2023 - 10 - 28 19 : 27 : 00 . 337929 - 05 | { \"hello\" : \"world\" } Deleting/Archiving Messages \u00b6 delete (single) \u00b6 Deletes a single message from a queue. pgmq.delete (queue_name text, msg_id: bigint) RETURNS boolean Parameters: Parameter Type Description queue_name text The name of the queue msg_id bigint Message ID of the message to delete Example: select pgmq . delete ( 'my_queue' , 5 ); delete -------- t delete (batch) \u00b6 Delete one or many messages from a queue. pgmq.delete (queue_name text, msg_ids: bigint[]) RETURNS SETOF bigint Parameters: Parameter Type Description queue_name text The name of the queue msg_ids bigint[] Array of message IDs to delete Examples: Delete two messages that exist. select * from pgmq . delete ( 'my_queue' , ARRAY [ 2 , 3 ]); delete -------- 2 3 Delete two messages, one that exists and one that does not. Message 999 does not exist. select * from pgmq . delete ( 'my_queue' , ARRAY [ 6 , 999 ]); delete -------- 6 purge_queue \u00b6 Permanently deletes all messages in a queue. Returns the number of messages that were deleted. purge_queue(queue_name text) RETURN bigint Parameters: Parameter Type Description queue_name text The name of the queue Example: Purge the queue when it contains 8 messages; select * from pgmq . purge_queue ( 'my_queue' ); purge_queue ------------- 8 archive (single) \u00b6 Removes a single requested message from the specified queue and inserts it into the queue's archive. pgmq.archive(queue_name text, msg_id bigint) RETURNS boolean Parameters: Parameter Type Description queue_name text The name of the queue msg_id bigint Message ID of the message to archive Returns Boolean value indicating success or failure of the operation. Example; remove message with ID 1 from queue my_queue and archive it: SELECT * FROM pgmq . archive ( 'my_queue' , 1 ); archive --------- t archive (batch) \u00b6 Deletes a batch of requested messages from the specified queue and inserts them into the queue's archive. Returns an ARRAY of message ids that were successfully archived. pgmq.archive(queue_name text, msg_ids bigint[]) RETURNS SETOF bigint Parameters: Parameter Type Description queue_name text The name of the queue msg_ids bigint[] Array of message IDs to archive Examples: Delete messages with ID 1 and 2 from queue my_queue and move to the archive. SELECT * FROM pgmq . archive ( 'my_queue' , ARRAY [ 1 , 2 ]); archive --------- 1 2 Delete messages 4, which exists and 999, which does not exist. select * from pgmq . archive ( 'my_queue' , ARRAY [ 4 , 999 ]); archive --------- 4 Queue Management \u00b6 create \u00b6 Create a new queue. pgmq.create(queue_name text) RETURNS VOID Parameters: Parameter Type Description queue_name text The name of the queue Example: select from pgmq . create ( 'my_queue' ); create -------- create_partitioned \u00b6 Create a partitioned queue. pgmq.create_partitioned ( queue-ue_name text, partition_interval text DEFAULT '10000'::text, retention_interval text DEFAULT '100000'::text ) RETURNS void Parameters: Parameter Type Description queue_name text The name of the queue partition_interval text The name of the queue retention_interval text The name of the queue Example: Create a queue with 100,000 messages per partition, and will retain 10,000,000 messages on old partitions. Partitions greater than this will be deleted. select from pgmq . create_partitioned ( 'my_partitioned_queue' , '100000' , '10000000' ); create_partitioned -------------------- create_unlogged \u00b6 Creates an unlogged table. This is useful when write throughput is more important that durability. See Postgres documentation for unlogged tables for more information. pgmq.create_unlogged(queue_name text) RETURNS void Parameters: Parameter Type Description queue_name text The name of the queue Example: select pgmq . create_unlogged ( 'my_unlogged' ); create_unlogged ----------------- detach_archive \u00b6 Drop the queue's archive table as a member of the PGMQ extension. Useful for preventing the queue's archive table from being drop when DROP EXTENSION pgmq is executed. This does not prevent the further archives() from appending to the archive table. pgmq.detach_archive(queue_name text) Parameters: Parameter Type Description queue_name text The name of the queue Example: select * from pgmq . detach_archive ( 'my_queue' ); detach_archive ---------------- drop_queue \u00b6 Deletes a queue and its archive table. pgmq.drop_queue(queue_name text) RETURNS boolean Parameters: Parameter Type Description queue_name text The name of the queue Example: select * from pgmq . drop_queue ( 'my_unlogged' ); drop_queue ------------ t Utilities \u00b6 set_vt \u00b6 Sets the visibility timeout of a message to a specified time duration in the future. Returns the record of the message that was updated. pgmq.set_vt( queue_name text, msg_id bigint, vt_offset integer ) RETURNS pgmq.message_record Parameters: Parameter Type Description queue_name text The name of the queue msg_id bigint ID of the message to set visibility time vt_offset integer Duration from now, in seconds, that the message's VT should be set to Example: Set the visibility timeout of message 1 to 30 seconds from now. select * from pgmq . set_vt ( 'my_queue' , 11 , 30 ); msg_id | read_ct | enqueued_at | vt | message --------+---------+-------------------------------+-------------------------------+---------------------- 1 | 0 | 2023 - 10 - 28 19 : 42 : 21 . 778741 - 05 | 2023 - 10 - 28 19 : 59 : 34 . 286462 - 05 | { \"hello\" : \"world_0\" } list_queues \u00b6 List all the queues that currently exist. list_queues () RETURNS TABLE ( queue_name text , created_at timestamp with time zone , is_partitioned boolean , is_unlogged boolean ) Example: select * from pgmq . list_queues (); queue_name | created_at | is_partitioned | is_unlogged ----------------------+-------------------------------+----------------+------------- my_queue | 2023 - 10 - 28 14 : 13 : 17 . 092576 - 05 | f | f my_partitioned_queue | 2023 - 10 - 28 19 : 47 : 37 . 098692 - 05 | t | f my_unlogged | 2023 - 10 - 28 20 : 02 : 30 . 976109 - 05 | f | t metrics \u00b6 Get metrics for a specific queue. pgmq.metrics(queue_name: text) RETURNS TABLE( queue_name text, queue_length bigint, newest_msg_age_sec integer, oldest_msg_age_sec integer, total_messages bigint, scrape_time timestamp with time zone ) Parameters: Parameter Type Description queue_name text The name of the queue Returns: Attribute Type Description queue_name text The name of the queue queue_length bigint Number of messages currently in the queue newest_msg_age_sec integer | null Age of the newest message in the queue, in seconds oldest_msg_age_sec integer | null Age of the oldest message in the queue, in seconds total_messages bigint Total number of messages that have passed through the queue over all time scrape_time timestamp with time zone The current timestamp Example: select * from pgmq . metrics ( 'my_queue' ); queue_name | queue_length | newest_msg_age_sec | oldest_msg_age_sec | total_messages | scrape_time ------------+--------------+--------------------+--------------------+----------------+------------------------------- my_queue | 16 | 2445 | 2447 | 35 | 2023 - 10 - 28 20 : 23 : 08 . 406259 - 05 metrics_all \u00b6 Get metrics for all existing queues. pgmq.metrics_all() RETURNS TABLE( queue_name text, queue_length bigint, newest_msg_age_sec integer, oldest_msg_age_sec integer, total_messages bigint, scrape_time timestamp with time zone ) Returns: Attribute Type Description queue_name text The name of the queue queue_length bigint Number of messages currently in the queue newest_msg_age_sec integer | null Age of the newest message in the queue, in seconds oldest_msg_age_sec integer | null Age of the oldest message in the queue, in seconds total_messages bigint Total number of messages that have passed through the queue over all time scrape_time timestamp with time zone The current timestamp select * from pgmq . metrics_all (); queue_name | queue_length | newest_msg_age_sec | oldest_msg_age_sec | total_messages | scrape_time ----------------------+--------------+--------------------+--------------------+----------------+------------------------------- my_queue | 16 | 2563 | 2565 | 35 | 2023 - 10 - 28 20 : 25 : 07 . 016413 - 05 my_partitioned_queue | 1 | 11 | 11 | 1 | 2023 - 10 - 28 20 : 25 : 07 . 016413 - 05 my_unlogged | 1 | 3 | 3 | 1 | 2023 - 10 - 28 20 : 25 : 07 . 016413 - 05","title":"Functions"},{"location":"api/sql/functions/#functions","text":"","title":"Functions"},{"location":"api/sql/functions/#sending-messages","text":"","title":"Sending Messages"},{"location":"api/sql/functions/#send","text":"Send a single message to a queue. pgmq.send( queue_name text, msg jsonb, delay integer DEFAULT 0 ) RETURNS SETOF bigint Parameters: Parameter Type Description queue_name text The name of the queue msg jsonb The message to send to the queue delay integer Time in seconds before the message becomes visible. Defaults to 0. Example: select * from pgmq . send ( 'my_queue' , '{\"hello\": \"world\"}' ); send ------ 4","title":"send"},{"location":"api/sql/functions/#send_batch","text":"Send 1 or more messages to a queue. pgmq.send_batch( queue_name text, msgs jsonb[], delay integer DEFAULT 0 ) RETURNS SETOF bigint Parameters: Parameter Type Description queue_name text The name of the queue msgs jsonb[] Array of messages to send to the queue delay integer Time in seconds before the messages becomes visible. Defaults to 0. select * from pgmq . send_batch ( 'my_queue' , ARRAY [ '{\"hello\": \"world_0\"}' :: jsonb , '{\"hello\": \"world_1\"}' :: jsonb ] ); send_batch ------------ 1 2","title":"send_batch"},{"location":"api/sql/functions/#reading-messages","text":"","title":"Reading Messages"},{"location":"api/sql/functions/#read","text":"Read 1 or more messages from a queue. The VT specifies the amount of time in seconds that the message will be invisible to other consumers after reading. pgmq.read( queue_name text, vt integer, qty integer) RETURNS SETOF pgmq.message_record Parameters: Parameter Type Description queue_name text The name of the queue vt integer Time in seconds that the message become invisible after reading qty integer The number of messages to read from the queue. Defaults to 1 Example: select * from pgmq . read ( 'my_queue' , 10 , 2 ); msg_id | read_ct | enqueued_at | vt | message --------+---------+-------------------------------+-------------------------------+---------------------- 1 | 1 | 2023 - 10 - 28 19 : 14 : 47 . 356595 - 05 | 2023 - 10 - 28 19 : 17 : 08 . 608922 - 05 | { \"hello\" : \"world_0\" } 2 | 1 | 2023 - 10 - 28 19 : 14 : 47 . 356595 - 05 | 2023 - 10 - 28 19 : 17 : 08 . 608974 - 05 | { \"hello\" : \"world_1\" } ( 2 rows )","title":"read"},{"location":"api/sql/functions/#read_with_poll","text":"Same as read(). Also provides convenient long-poll functionality. When there are no messages in the queue, the function call will wait for max_poll_seconds in duration before returning. If messages reach the queue during that duration, they will be read and returned immediately. pgmq.read_with_poll( queue_name text, vt integer, qty integer, max_poll_seconds integer DEFAULT 5, poll_interval_ms integer DEFAULT 100 ) RETURNS SETOF pgmq.message_record Parameters: Parameter Type Description queue_name text The name of the queue vt integer Time in seconds that the message become invisible after reading. qty integer The number of messages to read from the queue. Defaults to 1. max_poll_seconds integer Time in seconds to wait for new messages to reach the queue. Defaults to 5. poll_interval_ms integer Milliseconds between the internal poll operations. Defaults to 100. Example: select * from pgmq . read_with_poll ( 'my_queue' , 1 , 1 , 5 , 100 ); msg_id | read_ct | enqueued_at | vt | message --------+---------+-------------------------------+-------------------------------+-------------------- 1 | 1 | 2023 - 10 - 28 19 : 09 : 09 . 177756 - 05 | 2023 - 10 - 28 19 : 27 : 00 . 337929 - 05 | { \"hello\" : \"world\" }","title":"read_with_poll"},{"location":"api/sql/functions/#pop","text":"Reads a single message from a queue and deletes it upon read. Note: utilization of pop() results in at-most-once delivery semantics if the consuming application does not guarantee processing of the message. pgmq.pop(queue_name text) RETURNS SETOF pgmq.message_record Parameters: Parameter Type Description queue_name text The name of the queue Example: pgmq =# select * from pgmq . pop ( 'my_queue' ); msg_id | read_ct | enqueued_at | vt | message --------+---------+-------------------------------+-------------------------------+-------------------- 1 | 2 | 2023 - 10 - 28 19 : 09 : 09 . 177756 - 05 | 2023 - 10 - 28 19 : 27 : 00 . 337929 - 05 | { \"hello\" : \"world\" }","title":"pop"},{"location":"api/sql/functions/#deletingarchiving-messages","text":"","title":"Deleting/Archiving Messages"},{"location":"api/sql/functions/#delete-single","text":"Deletes a single message from a queue. pgmq.delete (queue_name text, msg_id: bigint) RETURNS boolean Parameters: Parameter Type Description queue_name text The name of the queue msg_id bigint Message ID of the message to delete Example: select pgmq . delete ( 'my_queue' , 5 ); delete -------- t","title":"delete (single)"},{"location":"api/sql/functions/#delete-batch","text":"Delete one or many messages from a queue. pgmq.delete (queue_name text, msg_ids: bigint[]) RETURNS SETOF bigint Parameters: Parameter Type Description queue_name text The name of the queue msg_ids bigint[] Array of message IDs to delete Examples: Delete two messages that exist. select * from pgmq . delete ( 'my_queue' , ARRAY [ 2 , 3 ]); delete -------- 2 3 Delete two messages, one that exists and one that does not. Message 999 does not exist. select * from pgmq . delete ( 'my_queue' , ARRAY [ 6 , 999 ]); delete -------- 6","title":"delete (batch)"},{"location":"api/sql/functions/#purge_queue","text":"Permanently deletes all messages in a queue. Returns the number of messages that were deleted. purge_queue(queue_name text) RETURN bigint Parameters: Parameter Type Description queue_name text The name of the queue Example: Purge the queue when it contains 8 messages; select * from pgmq . purge_queue ( 'my_queue' ); purge_queue ------------- 8","title":"purge_queue"},{"location":"api/sql/functions/#archive-single","text":"Removes a single requested message from the specified queue and inserts it into the queue's archive. pgmq.archive(queue_name text, msg_id bigint) RETURNS boolean Parameters: Parameter Type Description queue_name text The name of the queue msg_id bigint Message ID of the message to archive Returns Boolean value indicating success or failure of the operation. Example; remove message with ID 1 from queue my_queue and archive it: SELECT * FROM pgmq . archive ( 'my_queue' , 1 ); archive --------- t","title":"archive (single)"},{"location":"api/sql/functions/#archive-batch","text":"Deletes a batch of requested messages from the specified queue and inserts them into the queue's archive. Returns an ARRAY of message ids that were successfully archived. pgmq.archive(queue_name text, msg_ids bigint[]) RETURNS SETOF bigint Parameters: Parameter Type Description queue_name text The name of the queue msg_ids bigint[] Array of message IDs to archive Examples: Delete messages with ID 1 and 2 from queue my_queue and move to the archive. SELECT * FROM pgmq . archive ( 'my_queue' , ARRAY [ 1 , 2 ]); archive --------- 1 2 Delete messages 4, which exists and 999, which does not exist. select * from pgmq . archive ( 'my_queue' , ARRAY [ 4 , 999 ]); archive --------- 4","title":"archive (batch)"},{"location":"api/sql/functions/#queue-management","text":"","title":"Queue Management"},{"location":"api/sql/functions/#create","text":"Create a new queue. pgmq.create(queue_name text) RETURNS VOID Parameters: Parameter Type Description queue_name text The name of the queue Example: select from pgmq . create ( 'my_queue' ); create --------","title":"create"},{"location":"api/sql/functions/#create_partitioned","text":"Create a partitioned queue. pgmq.create_partitioned ( queue-ue_name text, partition_interval text DEFAULT '10000'::text, retention_interval text DEFAULT '100000'::text ) RETURNS void Parameters: Parameter Type Description queue_name text The name of the queue partition_interval text The name of the queue retention_interval text The name of the queue Example: Create a queue with 100,000 messages per partition, and will retain 10,000,000 messages on old partitions. Partitions greater than this will be deleted. select from pgmq . create_partitioned ( 'my_partitioned_queue' , '100000' , '10000000' ); create_partitioned --------------------","title":"create_partitioned"},{"location":"api/sql/functions/#create_unlogged","text":"Creates an unlogged table. This is useful when write throughput is more important that durability. See Postgres documentation for unlogged tables for more information. pgmq.create_unlogged(queue_name text) RETURNS void Parameters: Parameter Type Description queue_name text The name of the queue Example: select pgmq . create_unlogged ( 'my_unlogged' ); create_unlogged -----------------","title":"create_unlogged"},{"location":"api/sql/functions/#detach_archive","text":"Drop the queue's archive table as a member of the PGMQ extension. Useful for preventing the queue's archive table from being drop when DROP EXTENSION pgmq is executed. This does not prevent the further archives() from appending to the archive table. pgmq.detach_archive(queue_name text) Parameters: Parameter Type Description queue_name text The name of the queue Example: select * from pgmq . detach_archive ( 'my_queue' ); detach_archive ----------------","title":"detach_archive"},{"location":"api/sql/functions/#drop_queue","text":"Deletes a queue and its archive table. pgmq.drop_queue(queue_name text) RETURNS boolean Parameters: Parameter Type Description queue_name text The name of the queue Example: select * from pgmq . drop_queue ( 'my_unlogged' ); drop_queue ------------ t","title":"drop_queue"},{"location":"api/sql/functions/#utilities","text":"","title":"Utilities"},{"location":"api/sql/functions/#set_vt","text":"Sets the visibility timeout of a message to a specified time duration in the future. Returns the record of the message that was updated. pgmq.set_vt( queue_name text, msg_id bigint, vt_offset integer ) RETURNS pgmq.message_record Parameters: Parameter Type Description queue_name text The name of the queue msg_id bigint ID of the message to set visibility time vt_offset integer Duration from now, in seconds, that the message's VT should be set to Example: Set the visibility timeout of message 1 to 30 seconds from now. select * from pgmq . set_vt ( 'my_queue' , 11 , 30 ); msg_id | read_ct | enqueued_at | vt | message --------+---------+-------------------------------+-------------------------------+---------------------- 1 | 0 | 2023 - 10 - 28 19 : 42 : 21 . 778741 - 05 | 2023 - 10 - 28 19 : 59 : 34 . 286462 - 05 | { \"hello\" : \"world_0\" }","title":"set_vt"},{"location":"api/sql/functions/#list_queues","text":"List all the queues that currently exist. list_queues () RETURNS TABLE ( queue_name text , created_at timestamp with time zone , is_partitioned boolean , is_unlogged boolean ) Example: select * from pgmq . list_queues (); queue_name | created_at | is_partitioned | is_unlogged ----------------------+-------------------------------+----------------+------------- my_queue | 2023 - 10 - 28 14 : 13 : 17 . 092576 - 05 | f | f my_partitioned_queue | 2023 - 10 - 28 19 : 47 : 37 . 098692 - 05 | t | f my_unlogged | 2023 - 10 - 28 20 : 02 : 30 . 976109 - 05 | f | t","title":"list_queues"},{"location":"api/sql/functions/#metrics","text":"Get metrics for a specific queue. pgmq.metrics(queue_name: text) RETURNS TABLE( queue_name text, queue_length bigint, newest_msg_age_sec integer, oldest_msg_age_sec integer, total_messages bigint, scrape_time timestamp with time zone ) Parameters: Parameter Type Description queue_name text The name of the queue Returns: Attribute Type Description queue_name text The name of the queue queue_length bigint Number of messages currently in the queue newest_msg_age_sec integer | null Age of the newest message in the queue, in seconds oldest_msg_age_sec integer | null Age of the oldest message in the queue, in seconds total_messages bigint Total number of messages that have passed through the queue over all time scrape_time timestamp with time zone The current timestamp Example: select * from pgmq . metrics ( 'my_queue' ); queue_name | queue_length | newest_msg_age_sec | oldest_msg_age_sec | total_messages | scrape_time ------------+--------------+--------------------+--------------------+----------------+------------------------------- my_queue | 16 | 2445 | 2447 | 35 | 2023 - 10 - 28 20 : 23 : 08 . 406259 - 05","title":"metrics"},{"location":"api/sql/functions/#metrics_all","text":"Get metrics for all existing queues. pgmq.metrics_all() RETURNS TABLE( queue_name text, queue_length bigint, newest_msg_age_sec integer, oldest_msg_age_sec integer, total_messages bigint, scrape_time timestamp with time zone ) Returns: Attribute Type Description queue_name text The name of the queue queue_length bigint Number of messages currently in the queue newest_msg_age_sec integer | null Age of the newest message in the queue, in seconds oldest_msg_age_sec integer | null Age of the oldest message in the queue, in seconds total_messages bigint Total number of messages that have passed through the queue over all time scrape_time timestamp with time zone The current timestamp select * from pgmq . metrics_all (); queue_name | queue_length | newest_msg_age_sec | oldest_msg_age_sec | total_messages | scrape_time ----------------------+--------------+--------------------+--------------------+----------------+------------------------------- my_queue | 16 | 2563 | 2565 | 35 | 2023 - 10 - 28 20 : 25 : 07 . 016413 - 05 my_partitioned_queue | 1 | 11 | 11 | 1 | 2023 - 10 - 28 20 : 25 : 07 . 016413 - 05 my_unlogged | 1 | 3 | 3 | 1 | 2023 - 10 - 28 20 : 25 : 07 . 016413 - 05","title":"metrics_all"},{"location":"api/sql/types/","text":"Types \u00b6 message_record \u00b6 The complete representation of a message in a queue. Attribute Name Type Description msg_id bigint Unique ID of the message read_ct bigint Number of times the message has been read. Increments on read(). enqueued_at timestamp with time zone time that the message was inserted into the queue vt timestamp with time zone Timestamp when the message will become available for consumers to read message jsonb The message payload Example: msg_id | read_ct | enqueued_at | vt | message --------+---------+-------------------------------+-------------------------------+-------------------- 1 | 1 | 2023-10-28 19:06:19.941509-05 | 2023-10-28 19:06:27.419392-05 | {\"hello\": \"world\"}","title":"Types"},{"location":"api/sql/types/#types","text":"","title":"Types"},{"location":"api/sql/types/#message_record","text":"The complete representation of a message in a queue. Attribute Name Type Description msg_id bigint Unique ID of the message read_ct bigint Number of times the message has been read. Increments on read(). enqueued_at timestamp with time zone time that the message was inserted into the queue vt timestamp with time zone Timestamp when the message will become available for consumers to read message jsonb The message payload Example: msg_id | read_ct | enqueued_at | vt | message --------+---------+-------------------------------+-------------------------------+-------------------- 1 | 1 | 2023-10-28 19:06:19.941509-05 | 2023-10-28 19:06:27.419392-05 | {\"hello\": \"world\"}","title":"message_record"}]}